#include "distance.h"
template <typename T>
__device__ __host__ void PointLineDistanceVal(T &val, const Eigen::Vector<T, 2> &p, const Eigen::Vector<T, 2> &e0, const Eigen::Vector<T, 2> &e1)
{
    /*****************************************************************************************************************************
    Function generated by SymEigen.py
    Author: MuGdxy
    GitHub: https://github.com/MuGdxy/SymEigen
    E-Mail: lxy819469559@gmail.com
    ******************************************************************************************************************************
    Symbol Name Mapping:
    p:
        -> {}
        -> Matrix([[p(0)], [p(1)]])
    e0:
        -> {}
        -> Matrix([[e0(0)], [e0(1)]])
    e1:
        -> {}
        -> Matrix([[e1(0)], [e1(1)]])
    *****************************************************************************************************************************/
    /* Sub Exprs */
    auto x0 = -e0(0) + e1(0);
    auto x1 = -e0(1) + e1(1);
    /* Simplified Expr */
    val = (-e0(0) * e1(1) + e0(1) * e1(0) + p(0) * x1 - p(1) * x0) * (-e0(0) * e1(1) + e0(1) * e1(0) + p(0) * x1 - p(1) * x0) / ((x0) * (x0) + (x1) * (x1));
}

template <typename T>
__device__ __host__ void PointLineDistanceGrad(Eigen::Vector<T, 6> &grad, const Eigen::Vector<T, 2> &p, const Eigen::Vector<T, 2> &e0, const Eigen::Vector<T, 2> &e1)
{
    /*****************************************************************************************************************************
    Function generated by SymEigen.py
    Author: MuGdxy
    GitHub: https://github.com/MuGdxy/SymEigen
    E-Mail: lxy819469559@gmail.com
    ******************************************************************************************************************************
    Symbol Name Mapping:
    p:
        -> {}
        -> Matrix([[p(0)], [p(1)]])
    e0:
        -> {}
        -> Matrix([[e0(0)], [e0(1)]])
    e1:
        -> {}
        -> Matrix([[e1(0)], [e1(1)]])
    *****************************************************************************************************************************/
    /* Sub Exprs */
    auto x0 = 2 * e0(1);
    auto x1 = 2 * e1(1);
    auto x2 = x0 - x1;
    auto x3 = -x2;
    auto x4 = -e0(0) + e1(0);
    auto x5 = -e0(1) + e1(1);
    auto x6 = (x4) * (x4) + (x5) * (x5);
    auto x7 = -e0(0) * e1(1) + e0(1) * e1(0) + p(0) * x5 - p(1) * x4;
    auto x8 = x7 / x6;
    auto x9 = 2 * e0(0);
    auto x10 = 2 * e1(0);
    auto x11 = -x10 + x9;
    auto x12 = -2 * p(1);
    auto x13 = (x7) * (x7) / (x6) * (x6);
    auto x14 = -2 * p(0);
    /* Simplified Expr */
    grad(0) = x3 * x8;
    grad(1) = x11 * x8;
    grad(2) = -x11 * x13 + x8 * (-x1 - x12);
    grad(3) = x13 * x3 + x8 * (x10 + x14);
    grad(4) = x11 * x13 + x8 * (x0 + x12);
    grad(5) = x13 * x2 + x8 * (-x14 - x9);
}

template <typename T>
__device__ __host__ void PointLineDistanceHess(Eigen::Matrix<T, 6, 6> &hess, const Eigen::Vector<T, 2> &p, const Eigen::Vector<T, 2> &e0, const Eigen::Vector<T, 2> &e1)
{
    /*****************************************************************************************************************************
    Function generated by SymEigen.py
    Author: MuGdxy
    GitHub: https://github.com/MuGdxy/SymEigen
    E-Mail: lxy819469559@gmail.com
    ******************************************************************************************************************************
    Symbol Name Mapping:
    p:
        -> {}
        -> Matrix([[p(0)], [p(1)]])
    e0:
        -> {}
        -> Matrix([[e0(0)], [e0(1)]])
    e1:
        -> {}
        -> Matrix([[e1(0)], [e1(1)]])
    *****************************************************************************************************************************/
    /* Sub Exprs */
    auto x0 = -e0(1) + e1(1);
    auto x1 = e0(0) - e1(0);
    auto x2 = -x1;
    auto x3 = (x0) * (x0) + (x2) * (x2);
    auto x4 = 1.0 / (x3);
    auto x5 = 2 * e0(1);
    auto x6 = 2 * e1(1);
    auto x7 = x5 - x6;
    auto x8 = -x7;
    auto x9 = x4 * x8;
    auto x10 = -p(1);
    auto x11 = -e1(1) - x10;
    auto x12 = 2 * e0(0);
    auto x13 = -2 * e1(0) + x12;
    auto x14 = -x13;
    auto x15 = -e0(0) * e1(1) + e0(1) * e1(0) + p(0) * x0 - p(1) * x2;
    auto x16 = pow(x3, -2);
    auto x17 = x15 * x16;
    auto x18 = x17 * x8;
    auto x19 = x14 * x18;
    auto x20 = -p(0);
    auto x21 = e1(0) + x20;
    auto x22 = 2 * x15;
    auto x23 = x22 * x4;
    auto x24 = -x23;
    auto x25 = x17 * (x8) * (x8) + x24;
    auto x26 = e0(1) + x10;
    auto x27 = x13 * x18;
    auto x28 = -e0(0) - x20;
    auto x29 = x18 * x7 + x23;
    auto x30 = x13 * x4;
    auto x31 = x13 * x17;
    auto x32 = x14 * x31 + x23;
    auto x33 = (x13) * (x13)*x17 + x24;
    auto x34 = x31 * x7;
    auto x35 = -2 * p(1);
    auto x36 = -x35 - x6;
    auto x37 = x36 * x4;
    auto x38 = (x15) * (x15);
    auto x39 = 2 * x16 * x38;
    auto x40 = -x39;
    auto x41 = x16 * x22;
    auto x42 = 4 * e0(0) - 4 * e1(0);
    auto x43 = -x42;
    auto x44 = x38 / (x3) * (x3) * (x3);
    auto x45 = x14 * x44;
    auto x46 = 4 * e0(1) - 4 * e1(1);
    auto x47 = -x46;
    auto x48 = -2 * p(0);
    auto x49 = 2 * e1(0) + x48;
    auto x50 = x14 * x17;
    auto x51 = x18 * x36 + x49 * x50;
    auto x52 = x35 + x5;
    auto x53 = x31 * x36 + x39 + x50 * x52;
    auto x54 = -x12 - x48;
    auto x55 = x17 * x7;
    auto x56 = x24 + x36 * x55 + x50 * x54;
    auto x57 = x4 * x49;
    auto x58 = x44 * x8;
    auto x59 = x18 * x52 + x23 + x31 * x49;
    auto x60 = x18 * x54 + x39 + x49 * x55;
    auto x61 = x4 * x52;
    auto x62 = x13 * x44;
    auto x63 = x31 * x54 + x52 * x55;
    auto x64 = x4 * x54;
    auto x65 = x44 * x7;
    /* Simplified Expr */
    hess(0, 0) = x0 * x9;
    hess(0, 1) = x1 * x9;
    hess(0, 2) = x11 * x9 + x19;
    hess(0, 3) = x21 * x9 + x25;
    hess(0, 4) = x26 * x9 + x27;
    hess(0, 5) = x28 * x9 + x29;
    hess(1, 0) = x0 * x30;
    hess(1, 1) = x1 * x30;
    hess(1, 2) = x11 * x30 + x32;
    hess(1, 3) = x21 * x30 + x27;
    hess(1, 4) = x26 * x30 + x33;
    hess(1, 5) = x28 * x30 + x34;
    hess(2, 0) = x0 * x37 + x19;
    hess(2, 1) = x1 * x37 + x32;
    hess(2, 2) = x11 * x37 + x14 * x36 * x41 + x40 + x43 * x45;
    hess(2, 3) = x21 * x37 + x45 * x47 + x51;
    hess(2, 4) = x26 * x37 + x42 * x45 + x53;
    hess(2, 5) = x28 * x37 + x45 * x46 + x56;
    hess(3, 0) = x0 * x57 + x25;
    hess(3, 1) = x1 * x57 + x27;
    hess(3, 2) = x11 * x57 + x43 * x58 + x51;
    hess(3, 3) = x21 * x57 + x40 + x41 * x49 * x8 + x47 * x58;
    hess(3, 4) = x26 * x57 + x42 * x58 + x59;
    hess(3, 5) = x28 * x57 + x46 * x58 + x60;
    hess(4, 0) = x0 * x61 + x27;
    hess(4, 1) = x1 * x61 + x33;
    hess(4, 2) = x11 * x61 + x43 * x62 + x53;
    hess(4, 3) = x21 * x61 + x47 * x62 + x59;
    hess(4, 4) = x13 * x41 * x52 + x26 * x61 + x40 + x42 * x62;
    hess(4, 5) = x28 * x61 + x46 * x62 + x63;
    hess(5, 0) = x0 * x64 + x29;
    hess(5, 1) = x1 * x64 + x34;
    hess(5, 2) = x11 * x64 + x43 * x65 + x56;
    hess(5, 3) = x21 * x64 + x47 * x65 + x60;
    hess(5, 4) = x26 * x64 + x42 * x65 + x63;
    hess(5, 5) = x28 * x64 + x40 + x41 * x54 * x7 + x46 * x65;
}

template __device__ __host__ void PointLineDistanceVal(float &val, const Eigen::Vector<float, 2> &p, const Eigen::Vector<float, 2> &e0, const Eigen::Vector<float, 2> &e1);
template __device__ __host__ void PointLineDistanceGrad(Eigen::Vector<float, 6> &grad, const Eigen::Vector<float, 2> &p, const Eigen::Vector<float, 2> &e0, const Eigen::Vector<float, 2> &e1);
template __device__ __host__ void PointLineDistanceHess(Eigen::Matrix<float, 6, 6> &hess, const Eigen::Vector<float, 2> &p, const Eigen::Vector<float, 2> &e0, const Eigen::Vector<float, 2> &e1);

template __device__ __host__ void PointLineDistanceVal(double &val, const Eigen::Vector<double, 2> &p, const Eigen::Vector<double, 2> &e0, const Eigen::Vector<double, 2> &e1);
template __device__ __host__ void PointLineDistanceGrad(Eigen::Vector<double, 6> &grad, const Eigen::Vector<double, 2> &p, const Eigen::Vector<double, 2> &e0, const Eigen::Vector<double, 2> &e1);
template __device__ __host__ void PointLineDistanceHess(Eigen::Matrix<double, 6, 6> &hess, const Eigen::Vector<double, 2> &p, const Eigen::Vector<double, 2> &e0, const Eigen::Vector<double, 2> &e1);